##### 反置页表也是一种为了减少页表所占用存储空间的一种做法

##### 提出反置页表的原因
    多级页表它访问存储空间的次数比较多,在大地址空间的情况下.

    由于大地址空间和多级页表
    它和逻辑地址空间的大小有对应关系，每一个逻辑页面都会对应着页表项的一项,那这样进程数目的增加都会导
    致页表的数目增多,占用的空间增大

    反置页表和页寄存器是两个类似的做法
    让页表项和物理地址空间的大小相对应起来,而不是说像多级页表里和逻辑地址空间相对应起来

#### 页寄存器
    它是把每一个物理帧和一个页寄存器相对应。
##### 寄存器存储的内容：
    1、使用位
        这个物理帧是否被某一个进程占用
    
    2、占用页号：
        占用页号相当于那个进程占用了这一页的逻辑页号，它的逻辑地址是多少
    3、保护位：
        是来约定这一页的访问方式，比如说可读 可写

##### 占用的存储：
    例子：
    它整个系统里有16M的物理内存，页面大小是4K
    有4096个页面，每一个页寄存器占8字节
    页表大小：40968=32K字节
    那这32K字节和16M物理内存比较起来呢占到的比例是0.2%
    那这个比例相对来说还是比较小的。
    同时它和虚拟内存的大小就没有关系了，所以创建多少进程都与页表占用的内存都没有关系了
##### 缺点：
	在多级页表里，从逻辑页号到物理页号，利用下标查找页表的内容，就可以找到它的页帧号
	按页帧号进行排序，在页寄存器里头进行搜索逻辑页号，这个搜索是会比较困难的

##### 页寄存器机制的地址转换
    CPU生成逻辑地址，把逻辑地址做Hash（可以减少搜索范围）
    
    逻辑地址进行Hash，然后在快表当中去查找相应的页表项
    如果说查找的过程当中出现冲突，就需要遍历所有的冲突链表
    查找不到，就会出现异常
    
    缺点：
    由于快表它的容量有限，快表的功耗又很大，这对于页寄存器机制还是有很大影响的，这是不可以忽视的

#### 反置页表：
    反置页表和页寄存器的做法的区别是，在于它把进程ID也考虑进来了
    它和页寄存器做法一样的，需要进行Hash，不同的地方是把进程标识，也加在里头一块做Hash。
##### 例子
    一个逻辑地址加上它的进程ID，首先做Hash到相应的反置页表当中进行查找
    看进程ID和逻辑页号，是不是跟Hash之前的一样
    如果不一样，说明有冲突，再找下一项，在下一项里头进行核对，直到找到不冲突的。
    它的序号就是页帧号，页帧号和页内偏移合到一起，那就得到了物理地址。
##### 三种做法来缓解或者是解决页表所带来的麻烦
    1、快表 
        它是通过缓存的机制，来减少对物理内存 对页表的访问
    2、多级页表
        通过多级来减少页表的大小。
    3、反置页表
        另一种减少页表大小的做法

